\select@language {french}
\select@language {greek}
\select@language {english}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces Overview of our futures library design.\relax }}{9}{figure.caption.4}
\contentsline {figure}{\numberline {2.2}{\ignorespaces A simple hello world implementation using the distributed futures interface. The output of the program on process 0 would be "- Master :Hello 1".\relax }}{11}{figure.caption.5}
\contentsline {figure}{\numberline {2.3}{\ignorespaces The control flow of the hello world program in figture~\ref {lst:hello}.\relax }}{12}{figure.caption.6}
\contentsline {figure}{\numberline {2.4}{\ignorespaces The \emph {async\_function} function class definition. All \emph {jobs} in our system are instances of this class. The base class \emph {\_job} is used for serialization purposes as well.\relax }}{13}{figure.caption.7}
\contentsline {figure}{\numberline {2.5}{\ignorespaces A fibonacci implementation using the distributed futures interface\relax }}{14}{figure.caption.8}
\contentsline {figure}{\numberline {2.6}{\ignorespaces The function used to set a future's value. The first version is for primitive data types, where as the second is for serializable objects.\relax }}{15}{figure.caption.9}
\contentsline {figure}{\numberline {2.7}{\ignorespaces Shared Memory Manager keeps a map of free lists, indexed by the page size. For page size that do not match any predefined ones, we use the \emph {other} page size free list.\relax }}{17}{figure.caption.10}
\contentsline {figure}{\numberline {2.8}{\ignorespaces During allocation, when a large enough space is found, the allocated page is removed from the node.\relax }}{18}{figure.caption.11}
\contentsline {figure}{\numberline {2.9}{\ignorespaces By freeing data at base pointer 512, creates a continuous space between base pointer 0 and base pointer 640, causing the list nodes to merge into one.\relax }}{19}{figure.caption.12}
\contentsline {figure}{\numberline {2.10}{\ignorespaces Shared stack where a worker process keeps its pending jobs. Entries can have varied sizes, this size is stored at the beginning of the entry and can be used to retrieve the corresponding job. Information for the specific stack,like size and head, are stored at the beginning of the shared space, so that other processes can access them.\relax }}{20}{figure.caption.13}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces Comparison between issuing functors with scalar arguments versus vector objects of size 1\relax }}{24}{figure.caption.14}
\contentsline {figure}{\numberline {3.2}{\ignorespaces Comparison between issuing functors with different number of vector arguments, but total size of arguments is the same in all cases.\relax }}{24}{figure.caption.15}
\contentsline {figure}{\numberline {3.3}{\ignorespaces Comparison between issuing functors with 1 vector argument of different sizes\relax }}{25}{figure.caption.16}
\contentsline {figure}{\numberline {3.4}{\ignorespaces A quicksort implementation using the distributed futures interface\relax }}{28}{figure.caption.17}
\contentsline {figure}{\numberline {3.5}{\ignorespaces The tiled LU kernel implementation\relax }}{29}{figure.caption.18}
\contentsline {figure}{\numberline {3.6}{\ignorespaces The tiled LU parallel kernel implementation\relax }}{29}{figure.caption.19}
\contentsline {figure}{\numberline {3.7}{\ignorespaces Scalability graph for fibonacci, quicksort and LU\relax }}{30}{figure.caption.20}
\contentsline {figure}{\numberline {3.8}{\ignorespaces Speedup graph for fibonacci, quicksort and LU\relax }}{30}{figure.caption.21}
\contentsline {figure}{\numberline {3.9}{\ignorespaces Breakdowns of master and worker execution time graph for fibonacci, quicksort and LU\relax }}{31}{figure.caption.22}
\contentsline {figure}{\numberline {3.10}{\ignorespaces Breakdowns of master and worker execution time graph for fibonacci, quicksort and LU, with initialization and finalization times\relax }}{31}{figure.caption.23}
\addvspace {10\p@ }
